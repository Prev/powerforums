import axios from 'axios';
import qs from 'qs';

/**
 * Handle common error of APIClient.
 * @param error: Error instance generated by axios.
 * @param callback: When error is not caught in this function, callback is called. (Like pipeline)
 */
function _pipeAPIError(error, callback) {
    switch (error.response.status){
        case 401:
            alert('Authentication failed');
            sessionStorage.removeItem('jwtToken');
            window.location.reload();
            return;
    }
    return callback(error);
}


/**
 * APIClient connected with API server
 */
export default class APIClient {
    constructor(apiUrl) {
        this.url = apiUrl;

        // Create an axios instance that will be used to send API requests, and store it as class attribute.
        this.httpClient = axios.create({ baseURL: this.url });

        // Need to defined a serializer function for parameters.
        this.httpClient.defaults.paramsSerializer = params => {
            return qs.stringify(params, { arrayFormat: 'brackets' })
        };
    }

    /**
     * Set authorization header field.
     * @param authorizationToken: JWT token generated in server.
     */
    setAuthorizationToken(authorizationToken) {
        this.httpClient.defaults.headers.common['Authorization'] = `Bearer ${authorizationToken}`;
    }

    /**
     * Try login with email and password
     * @param email: Email address of user
     * @param password: Password of user.
     */
    login(email, password) {
        return new Promise((fulfill, reject) => {
            return this.httpClient
                .post('/user/login', {
                    email: email,
                    password: password
                })
                .then(response => fulfill(response.data))
                .catch(error => reject(error))
        })
    }

    /**
     * Try sign-up.
     * @param user: Values required for register new user.
     */
    signUpUser(user) {
        return new Promise((fulfill, reject) => {
            return this.httpClient
                .put('/user/signup', user)
                .then(response => fulfill(response.data))
                .catch(error => reject(error));
        });
    }

    /**
     * Get node data by ID
     * @param nodeId: ID of node
     */
    getNodeById(nodeId) {
        return new Promise((fulfill, reject) => {
            this.httpClient
                .get('/node/' + nodeId)
                .then(response => fulfill(response.data))
                .catch(error => _pipeAPIError(error, reject))
        })
    }

    /**
     * Get node's children with pagination-control
     * @param parentId: ID of node contains children
     * @param page: Page index
     * @param perPage: Per page
     * @param sort: Sort options for pagination
     */
    getNodePaginatedChildren(parentId, page, perPage, sort = {}) {
        return new Promise((fulfill, reject) => {
            this.httpClient
                .get('/node/'+parentId+'/children', {
                    params: {
                        page: page,
                        perPage: perPage,
                        sort: sort
                    }
                })
                .then(response => fulfill(response.data))
                .catch(error => _pipeAPIError(error, reject));
        });
    }

    /**
     * Create a new node.
     * @param node: Properties of node.
     */
    createNode(node) {
        return new Promise((fulfill, reject) => {
            return this.httpClient
                .post('/node', node)
                .then(response => fulfill(response.data))
                .catch(error => _pipeAPIError(error, reject))
        });
    }

    /**
     * Delete specific node
     * @param nodeId: ID of node to delete
     */
    deleteNode(nodeId) {
        return new Promise((fulfill, reject) => {
            return this.httpClient
                .delete('/node/' + nodeId)
                .then(response => fulfill(response.data))
                .catch(error => _pipeAPIError(error, reject))
        })
    }

    /**
     * Update node with specific attributes. Only given keys are modified.
     * [Notice] Only give the attributes to modify. Do not give others.
     *          For example, `sticky` property is not allowed to send for normal user
     *          even if value is not changed.
     *
     * @param node: Value set to change.
     */
    updateNode(node) {
        return new Promise((fulfill, reject) => {
            return this.httpClient
                .patch('/node/' + node._id, node)
                .then(response => fulfill(response.data))
                .catch(error => _pipeAPIError(error, reject))
        })
    }

    /**
     * Set or unset sticky to node.
     * @param nodeId: ID of node
     * @param sticky: 1 or 0
     */
    stickNode(nodeId, sticky) {
        return new Promise((fulfill, reject) => {
            return this.httpClient
                .patch('/node/' + nodeId, { sticky: sticky })
                .then(response => fulfill(response.data))
                .catch(error => _pipeAPIError(error, reject))
        })
    }

    /*
    reportObject(param) {
        var self = this
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .put('/report', param, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => APIClient._handleSpecificError(error, reject))
        })
    }

    getRolePaginated(page, perPage, sort = {}) {
        var self = this
        return new Promise((fulfill, reject) => {
            self.httpClient
                .post('/role/getPaginated', {
                    page: page,
                    perPage: perPage,
                    sort: sort
                }, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(error, reject))
        })
    }


    createRole(role) {
        var self = this
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .put('/role', role, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(error, reject))
        })
    }


    deleteRole(roleId) {
        var self = this
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .delete('/role/' + roleId, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(error, reject))
        })
    }


    getUser(authorId) {
        var self = this;
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .get('/user/' + authorId, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(new Error(error), reject));
        });
    }


    getUserPaginated(page, perPage, sort = {}) {
        var self = this;
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .post('/user/getPaginated', {
                    page: page,
                    perPage: perPage,
                    sort: sort
                }, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(new Error(error), reject));
        });
    }

    createUser(user) {
        var self = this;
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .put('/user', user, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(error, reject));
        });
    }

    deleteUser(userId) {
        var self = this
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .delete('/user/' + userId, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(error, reject))
        })
    }

    createReport(report) {
        var self = this;
        return new Promise((fulfill, reject) => {
            return self.httpClient
                .put('/report', report, { headers: { 'Authorization': this.authorizationHeader } })
                .then(response => fulfill(response.data))
                .catch(error => this.handleSpecificError(error, reject));
        });
    }*/
}